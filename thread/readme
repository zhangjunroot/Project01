《Java并发编程实战》
《Java并发编程的艺术》方腾飞
《深入理解Java虚拟机》周志明
1在dos窗口输入jconsole查看本地后台运行了多少线程的Java程序,输入javap -verbose Sequence.class
2堆和方法区是被线程所共享的，虚拟机栈是每个线程所独有的
3程序计数器是每个线程所独有的
4多线程和并发
多线程不一定是并发（烤烧饼）
并发一定是多线程
5多线程和多进程
进程：运行中的程序
进程是资源分配的最小单位
进程包含多个线程，线程共享进程的资源
线程是cpu调度的基本单位
多线程一定快吗？（烤烧饼）
初始状态----就绪状态----运行状态----死亡状态
sleep和wait后进入等待状态，时间到或者被唤醒后进入就绪状态，不会进入死亡状态

线程的活跃性问题
死锁（五个科学家一人拿一根筷子）
饥饿（同一个窗口买饭）
活锁（一条河两个桥，两个人互相礼让）

线程的性能问题
多线程运行时的上下文切换，耗费CPU资源（烤饼）

饥饿与公平
高优先级吞噬所有低优先级的cup时间片
线程被永久堵塞在一个等待进入同步块的状态
等待的线程永远不被唤醒

如何尽量避免饥饿问题
 1设置合理的优先级
 2使用锁来代替sychronized

线程的优先级最小为1，最大为10，默认为5

内置锁：java中每个对象都可以看成是同步的锁，这些锁被称为内置锁。

任何对象都可以作为锁，那么锁信息又存在对象的什么地方呢？
存在对象头中

偏向锁：线程第一次执行同步代码块的时候获取锁，执行完不释放锁，当该线程再次来的时候不需要获取锁直接执行；但是当有其他线程
来的时候，和它竞争锁，他才会释放锁。使用场景是只有一个线程在访问同步代码块。

每次获取锁和释放锁会浪费资源
很多情况下，竞争锁不是由多个线程，而是由一个线程在使用。

轻量级锁：可以同时让多个线程进入同步代码块中执行代码，也就是能同时获取锁。

重入锁：两个方法使用同一个对象作为锁，当一个线程进入第一个方法，第一个方法调用第二个方法，这个时候这个线程也是能够进入
        第二个方法执行的，这个过程叫做锁重入。


x = 10;         //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4
 　　咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子
 性操作。
语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。
语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存
        这2个操作都是原子性操作，但是合起来就不是原子性操作了。
　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。
 　　所以上面4个语句只有语句1的操作具备原子性。

Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。
由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

对于可见性，Java提供了volatile关键字来保证可见性。

当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，
此时内存中可能还是原来的旧值，因此无法保证可见性。







